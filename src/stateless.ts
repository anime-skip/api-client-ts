// DO NOT EDIT, THIS IS A GENERATED FILE
// Generated by: src/generate/index.ts

import { GqlResponse, GqlError, StatelessConfig, ApiHealth } from './types';
import { DEFAULT_FETCH } from './fetch';

/**
 * The `Boolean` scalar type represents `true` or `false`.
 */
export type GqlBoolean = boolean;

/**
 * The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
 */
export type GqlFloat = number;

/**
 * The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as "4") or integer (such as 4) input value will be accepted as an ID.
 */
export type GqlID = string;

/**
 * The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
 */
export type GqlInt = number;

/**
 * The `String`scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
 */
export type GqlString = string;

/**
 * Standard [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp in UTC
 *
 * ### Example
 *
 * ```
 * 2020-08-04T23:43:27Z
 * ```
 */
export type GqlTime = string;

/**
 * Color theme the user prefers
 */
export enum GqlColorTheme {
  /**
   * Change to match where you're watching
   */
  PER_SERVICE = 'PER_SERVICE',
  ANIME_SKIP_BLUE = 'ANIME_SKIP_BLUE',
  VRV_YELLOW = 'VRV_YELLOW',
  FUNIMATION_PURPLE = 'FUNIMATION_PURPLE',
  CRUNCHYROLL_ORANGE = 'CRUNCHYROLL_ORANGE',
}

/**
 * Which of the supported services the `EpisodeUrl` was created for. This is a simple enum that allows
 * for simple checks, but this data can also be pulled from the url in the case of UNKNOWN
 */
export enum GqlEpisodeSource {
  /**
   * Data came from an external source
   */
  UNKNOWN = 'UNKNOWN',
  /**
   * Data is from <vrv.co>
   */
  VRV = 'VRV',
  /**
   * Data is from <funimation.com>
   */
  FUNIMATION = 'FUNIMATION',
}

/**
 * A user's role in the system. Higher roles allow a user write access to certain data that a normal
 * user would not. Some queries and mutations are only alloed by certain roles
 */
export enum GqlRole {
  /**
   * Highest role. Has super user access to all queries and mutations
   */
  DEV = 'DEV',
  /**
   * Administrator role. Has some elevated permissions
   */
  ADMIN = 'ADMIN',
  /**
   * Basic role. Has no elevated permissions
   */
  USER = 'USER',
}

/**
 * The scope that a template applies to
 */
export enum GqlTemplateType {
  /**
   * The template is loaded for all episodes of a given show
   */
  SHOW = 'SHOW',
  /**
   * The template is loaded for episodes of a given show where their season is included in `Template.seasons`
   */
  SEASONS = 'SEASONS',
}

/**
 * Where a timestamp originated from
 */
export enum GqlTimestampSource {
  ANIME_SKIP = 'ANIME_SKIP',
  BETTER_VRV = 'BETTER_VRV',
}

/**
 * Account info that should only be accessible by the authorised user
 */
export interface GqlAccount {
  id: GqlID;
  createdAt: GqlTime;
  deletedAt?: GqlTime | undefined;
  /**
   * Unique string slug that is the easy to remember identifier
   */
  username: GqlString;
  email: GqlString;
  /**
   * Url to an image that is the user's profile picture
   */
  profileUrl: GqlString;
  /**
   * The linking object that associates a user to the shows they are admins of.
   *
   * > This data is also accessible on the `User` model. It has been added here for convienience
   */
  adminOfShows: Array<GqlShowAdmin>;
  /**
   * If the user's email is verified. Emails must be verified before the user can call a mutation
   */
  emailVerified: GqlBoolean;
  /**
   * The user's administrative role. Most users are `Role.USER`
   */
  role: GqlRole;
  /**
   * The user's preferences
   */
  preferences: GqlPreferences;
}

/**
 * The base model has all the fields you would expect a fully fleshed out item in the database would
 * have. It is used to track who create, updated, and deleted items
 */
export interface GqlBaseModel {
  /**
   * Unique, v4 UUID. When asked for an `id` of an object, use this field
   */
  id: GqlID;
  /**
   * Time that the item was created at
   */
  createdAt: GqlTime;
  /**
   * The user's `id` that created the item
   */
  createdByUserId: GqlID;
  /**
   * The entire user that created the item
   */
  createdBy: GqlUser;
  /**
   * Time that the item was updated at
   */
  updatedAt: GqlTime;
  /**
   * The user's `id` that last updated the item
   */
  updatedByUserId: GqlID;
  /**
   * The entire user that last updated the item
   */
  updatedBy: GqlUser;
  /**
   * Time that the item was updated at. If this value is present, the item is considered deleted
   */
  deletedAt?: GqlTime | undefined;
  /**
   * The user's `id` that deleted the item
   */
  deletedByUserId?: GqlID | undefined;
  /**
   * The entire user that deleted the item
   */
  deletedBy?: GqlUser | undefined;
}

/**
 * Basic information about an episode, including season, numbers, a list of timestamps, and urls that
 * it can be watched at
 */
export interface GqlEpisode {
  id: GqlID;
  createdAt: GqlTime;
  createdByUserId: GqlID;
  createdBy: GqlUser;
  updatedAt: GqlTime;
  updatedByUserId: GqlID;
  updatedBy: GqlUser;
  deletedAt?: GqlTime | undefined;
  deletedByUserId?: GqlID | undefined;
  deletedBy?: GqlUser | undefined;
  /**
   * The season number that this episode belongs to
   *
   * ### Examples:
   *
   * - "1"
   * - "1 Directors Cut"
   * - "2"
   * - "Movies"
   */
  season?: GqlString | undefined;
  /**
   * The episode number in the current season
   *
   * ### Examples:
   *
   * - "1"
   * - "2"
   * - "5.5"
   * - "OVA 1"
   */
  number?: GqlString | undefined;
  /**
   * The absolute episode number out of all the episodes of the show. Generally only regular episodes
   * should have this field
   */
  absoluteNumber?: GqlString | undefined;
  /**
   * The duration of the episode's first url, which can be used to calculate a suggested offset for new
   * episode urls. Episodes at different URLs have different branding intros, and that difference can
   * be computed using: `EpisodeUrl.duration - Episode.baseDuration`
   * Generally, this works because each service has it's own branding at the beginning of the show, not
   * at the end of it
   */
  baseDuration?: GqlFloat | undefined;
  /**
   * The episode's name
   */
  name?: GqlString | undefined;
  /**
   * The show that the episode belongs to
   */
  show: GqlShow;
  /**
   * The id of the show that the episode blongs to
   */
  showId: GqlID;
  /**
   * The list of current timestamps.
   *
   * Timestamps are apart apart of the `Episode` instead of the `EpisodeUrl` so that they can be shared
   * between urls and not need duplicate data
   */
  timestamps: Array<GqlTimestamp>;
  /**
   * The list of urls and services that the episode can be accessed from
   */
  urls: Array<GqlEpisodeUrl>;
  /**
   * If the episode is the source episode for a `Template`, this will resolve to that template
   */
  template?: GqlTemplate | undefined;
}

/**
 * Stores information about what where an episode can be watched from
 */
export interface GqlEpisodeUrl {
  /**
   * The url that would take a user to watch the `episode`.
   *
   * This url should be stripped of all query params.
   */
  url: GqlString;
  createdAt: GqlTime;
  createdByUserId: GqlID;
  createdBy: GqlUser;
  updatedAt: GqlTime;
  updatedByUserId: GqlID;
  updatedBy: GqlUser;
  /**
   * The length of the episode at this url. For more information on why this field exists, check out
   * the `Episode.baseDuration`. If an `Episode` does not have a duration, that `Episode` and this
   * `EpisodeUrl` should be given the same value, and the `EpisodeUrl.timestampsOffset` should be set to 0
   */
  duration?: GqlFloat | undefined;
  /**
   * How much a episode's timestamps should be offset for this `EpisodeUrl`, since different services
   * have different branding animations, leading to offsets between services. This field can be edited
   * to whatever, but it should be suggested to be `EpisodeUrl.duration - Episode.baseDuration`.
   * It can be positive or negative.
   */
  timestampsOffset?: GqlFloat | undefined;
  /**
   * The `Episode.id` that this url belongs to
   */
  episodeId: GqlID;
  /**
   * The `Episode` that this url belongs to
   */
  episode: GqlEpisode;
  /**
   * What service this url points to. This is computed when the `EpisodeUrl` is created
   */
  source: GqlEpisodeSource;
}

/**
 * Data required to create a new `Episode`. See `Episode` for a description of each field
 */
export interface GqlInputEpisode {
  /**
   * See `Episode.season`
   */
  season?: GqlString | undefined;
  /**
   * See `Episode.number`
   */
  number?: GqlString | undefined;
  /**
   * See `Episode.absoluteNumber`
   */
  absoluteNumber?: GqlString | undefined;
  /**
   * See `Episode.name`
   */
  name?: GqlString | undefined;
  /**
   * See `Episode.baseDuration`
   */
  baseDuration?: GqlFloat | undefined;
}

/**
 * Data required to create a new `EpisodeUrl`. See `EpisodeUrl` for a description of each field
 */
export interface GqlInputEpisodeUrl {
  url: GqlString;
  duration?: GqlFloat | undefined;
  timestampsOffset?: GqlFloat | undefined;
}

export interface GqlInputExistingTimestamp {
  /**
   * The id of the timestamp you want to modify
   */
  id: GqlID;
  /**
   * The new values for the timestamp
   */
  timestamp: GqlInputTimestamp;
}

/**
 * Data used to update a user's `Preferences`. See `Preferences` for a description of each field. If a
 * field is not passed or passed as `null`, it will leave the value as is and skip updating it
 */
export interface GqlInputPreferences {
  enableAutoSkip?: GqlBoolean | undefined;
  enableAutoPlay?: GqlBoolean | undefined;
  minimizeToolbarWhenEditing?: GqlBoolean | undefined;
  hideTimelineWhenMinimized?: GqlBoolean | undefined;
  colorTheme?: GqlColorTheme | undefined;
  skipBranding?: GqlBoolean | undefined;
  skipIntros?: GqlBoolean | undefined;
  skipNewIntros?: GqlBoolean | undefined;
  skipMixedIntros?: GqlBoolean | undefined;
  skipRecaps?: GqlBoolean | undefined;
  skipFiller?: GqlBoolean | undefined;
  skipCanon?: GqlBoolean | undefined;
  skipTransitions?: GqlBoolean | undefined;
  skipCredits?: GqlBoolean | undefined;
  skipNewCredits?: GqlBoolean | undefined;
  skipMixedCredits?: GqlBoolean | undefined;
  skipPreview?: GqlBoolean | undefined;
  skipTitleCard?: GqlBoolean | undefined;
}

/**
 * Data required to create a new `Show`. See `Show` for a description of each field
 */
export interface GqlInputShow {
  name: GqlString;
  originalName?: GqlString | undefined;
  website?: GqlString | undefined;
  image?: GqlString | undefined;
}

/**
 * Data required to create a new `ShowAdmin`. See `ShowAdmin` for a description of each field
 */
export interface GqlInputShowAdmin {
  showId: GqlID;
  userId: GqlID;
}

/**
 * Data required to create a new template. See `Template` for a description of each field
 */
export interface GqlInputTemplate {
  showId: GqlID;
  type: GqlTemplateType;
  seasons: Array<GqlString>;
  sourceEpisodeId: GqlID;
}

/**
 * Data required to modify the timestamps on a template
 */
export interface GqlInputTemplateTimestamp {
  templateId: GqlID;
  timestampId: GqlID;
}

/**
 * Data required to create a new `Timestamp`. See `Timestamp` for a description of each field
 */
export interface GqlInputTimestamp {
  at: GqlFloat;
  typeId: GqlID;
  source?: GqlTimestampSource | undefined;
}

export interface GqlInputTimestampOn {
  /**
   * The episode id the timestamp will be created on
   */
  episodeId: GqlID;
  /**
   * The new values for the timestamp
   */
  timestamp: GqlInputTimestamp;
}

/**
 * Data required to create a new `TimestampType`. See `TimestampType` for a description of each field
 */
export interface GqlInputTimestampType {
  name: GqlString;
  description: GqlString;
}

/**
 * When logging in with a password or refresh token, you can get new tokens and account info
 */
export interface GqlLoginData {
  /**
   * A JWT that should be used in the header of all requests: `Authorization: Bearer <authToken>`
   */
  authToken: GqlString;
  /**
   * A JWT used for the `loginRefresh` query to get new `LoginData`
   */
  refreshToken: GqlString;
  /**
   * The personal account information of the user that got authenticated
   */
  account: GqlAccount;
}

/**
 * Where all the user preferences are stored. This includes what timestamps the user doesn't want to
 * watch
 */
export interface GqlPreferences {
  id: GqlID;
  createdAt: GqlTime;
  updatedAt: GqlTime;
  deletedAt?: GqlTime | undefined;
  /**
   * The `User.id` that this preferences object belongs to
   */
  userId: GqlID;
  /**
   * The `User` that the preferences belong to
   */
  user: GqlUser;
  /**
   * Whether or not the user wants to automatically skip section. Default: `true`
   */
  enableAutoSkip: GqlBoolean;
  /**
   * Whether or not the user wants to auto-play the videos. Default: `true`
   */
  enableAutoPlay: GqlBoolean;
  /**
   * Whether or not the bottom toolbar with the video progress and play button is minimized after
   * inactivity while editing
   */
  minimizeToolbarWhenEditing: GqlBoolean;
  /**
   * When false, timeline is pinned to the bottom of the screen after inactivity. When true, it is
   * hidden completely
   */
  hideTimelineWhenMinimized: GqlBoolean;
  colorTheme: GqlColorTheme;
  /**
   * Whether or not the user whats to skip branding timestamps. Default: `true`
   */
  skipBranding: GqlBoolean;
  /**
   * Whether or not the user whats to skip regular intros. Default: `true`
   */
  skipIntros: GqlBoolean;
  /**
   * Whether or not the user whats to skip the first of an intro. Default: `false`
   */
  skipNewIntros: GqlBoolean;
  /**
   * Whether or not the user whats to kip intros that have plot progression rather than the standard animation. Default: `false`
   */
  skipMixedIntros: GqlBoolean;
  /**
   * Whether or not the user whats to skip recaps at the beginning of episodes. Default: `true`
   */
  skipRecaps: GqlBoolean;
  /**
   * Whether or not the user whats to skip filler content. Default: `true`
   */
  skipFiller: GqlBoolean;
  /**
   * Whether or not the user whats to skip canon content. Default: `false`
   */
  skipCanon: GqlBoolean;
  /**
   * Whether or not the user whats to skip commertial transitions. Default: `true`
   */
  skipTransitions: GqlBoolean;
  /**
   * Whether or not the user whats to skip credits/outros. Default: `true`
   */
  skipCredits: GqlBoolean;
  /**
   * Whether or not the user whats to skip the first of a credits/outro. Default: `false`
   */
  skipNewCredits: GqlBoolean;
  /**
   * Whether or not the user whats to skip credits/outros that have plot progression rather than the standard animation. Default: `false`
   */
  skipMixedCredits: GqlBoolean;
  /**
   * Whether or not to skip the next episode's preview. Default: `true`
   */
  skipPreview: GqlBoolean;
  /**
   * Whether or not to skip an episode's static title card. Default: `true`
   */
  skipTitleCard: GqlBoolean;
}

/**
 * A show containing a list of episodes and relevate links
 */
export interface GqlShow {
  id: GqlID;
  createdAt: GqlTime;
  createdByUserId: GqlID;
  createdBy: GqlUser;
  updatedAt: GqlTime;
  updatedByUserId: GqlID;
  updatedBy: GqlUser;
  deletedAt?: GqlTime | undefined;
  deletedByUserId?: GqlID | undefined;
  deletedBy?: GqlUser | undefined;
  /**
   * The show name
   *
   * ### Examples
   *
   * - "Death Note"
   * - "My Hero Academia"
   */
  name: GqlString;
  /**
   * The show's original Japanese name
   *
   * ### Examples
   *
   * - "Desu Nōto"
   * - "Boku no Hīrō Akademia"
   */
  originalName?: GqlString | undefined;
  /**
   * A link to the anime's official website
   */
  website?: GqlString | undefined;
  /**
   * A link to a show poster
   */
  image?: GqlString | undefined;
  /**
   * The list of admins for the show
   */
  admins: Array<GqlShowAdmin>;
  /**
   * All the episodes that belong to the show
   */
  episodes: Array<GqlEpisode>;
  /**
   * All the templates that belong to this show
   */
  templates: Array<GqlTemplate>;
  /**
   * How many seasons are associated with this show
   */
  seasonCount: GqlInt;
  /**
   * How many episodes are apart of this show
   */
  episodeCount: GqlInt;
}

/**
 * A list of users that have elevated permissions when making changes to a show, it's episodes, and
 * timestamps. Show admins are responsible for approving any changes that users might submit.
 *
 * If a user has the `ADMIN` or `DEV` roles, they do not need to be show admins to approve changes or
 * make changes directly. Likewise, if a show doesn't have an admin, the user that create the
 * show/episode will have temporary access to editing the data until someone becomes that shows admin.
 *
 * Admins can be created using the API and will soon come to the Anime Skip player/website.
 */
export interface GqlShowAdmin {
  id: GqlID;
  createdAt: GqlTime;
  createdByUserId: GqlID;
  createdBy: GqlUser;
  updatedAt: GqlTime;
  updatedByUserId: GqlID;
  updatedBy: GqlUser;
  deletedAt?: GqlTime | undefined;
  deletedByUserId?: GqlID | undefined;
  deletedBy?: GqlUser | undefined;
  /**
   * The `Show.id` that the admin has elevated privileges for
   */
  showId: GqlID;
  /**
   * The `Show` that the admin has elevated privileges for
   */
  show: GqlShow;
  /**
   * The `User.id` that the admin privileges belong to
   */
  userId: GqlID;
  /**
   * The `User` that the admin privileges belong to
   */
  user: GqlUser;
}

/**
 * When no timestamps exist for a specific episode, templates are setup to provide fallback timestamps
 */
export interface GqlTemplate {
  id: GqlID;
  createdAt: GqlTime;
  createdByUserId: GqlID;
  createdBy: GqlUser;
  updatedAt: GqlTime;
  updatedByUserId: GqlID;
  updatedBy: GqlUser;
  deletedAt?: GqlTime | undefined;
  deletedByUserId?: GqlID | undefined;
  deletedBy?: GqlUser | undefined;
  /**
   * The id of the show that this template is for
   */
  showId: GqlID;
  /**
   * The show that this template is for
   */
  show: GqlShow;
  /**
   * Specify the scope of the template, if it's for the entire show, or just for a set of seasons
   */
  type: GqlTemplateType;
  /**
   * When the template is for a set of seasons, this is the set of seasons it is applied to
   */
  seasons: Array<GqlString>;
  /**
   * The id of the episode used to create the template. All the timestamps are from this episode
   */
  sourceEpisodeId: GqlID;
  /**
   * The episode used to create the template. All the timestamps are from this episode
   */
  sourceEpisode: GqlEpisode;
  /**
   * The list of timestamps that are apart of this template
   */
  timestamps: Array<GqlTimestamp>;
  /**
   * The list of timestamp ids that are apart of this template. Since this is a many-to-many
   * relationship, this field will resolve quicker than `timestamps` since it doesn't have to do an
   * extra join
   *
   * This is useful when you already got the episode and timestamps, and you just need to know what
   * timestamps are apart of the template
   */
  timestampIds: Array<GqlID>;
}

/**
 * The many to many object that links a timestamp to a template
 */
export interface GqlTemplateTimestamp {
  templateId: GqlID;
  template: GqlTemplate;
  timestampId: GqlID;
  timestamp: GqlTimestamp;
}

/**
 * Episode info provided by a third party. See `Episode` for a description of each field.
 *
 * When creating data based on this type, fill out and post an episode, then timestamps based on the
 * data here. All fields will map 1 to 1 with the exception of `source`. Since a source belongs to a
 * episode for third party data, but belongs to timestamps in Anime Skip, the source should be
 * propogated down to each of the timestamps. This way when more timestamps are added, a episode can
 * have muliple timestamp sources.
 *
 * > Make sure to fill out the `source` field so that original owner of the timestamp is maintained
 */
export interface GqlThirdPartyEpisode {
  /**
   * The Anime Skip `Episode.id` when the `source` is `ANIME_SKIP`, otherwise this is null
   */
  id?: GqlID | undefined;
  season?: GqlString | undefined;
  number?: GqlString | undefined;
  absoluteNumber?: GqlString | undefined;
  baseDuration?: GqlFloat | undefined;
  name?: GqlString | undefined;
  source?: GqlTimestampSource | undefined;
  timestamps: Array<GqlThirdPartyTimestamp>;
  /**
   * The id of the show from the third party
   */
  showId: GqlString;
  show: GqlThirdPartyShow;
}

export interface GqlThirdPartyShow {
  name: GqlString;
  createdAt?: GqlTime | undefined;
  updatedAt?: GqlTime | undefined;
}

export interface GqlThirdPartyTimestamp {
  /**
   * The Anime Skip `Timestamp.id` when the `Episode.source` is `ANIME_SKIP`, otherwise this is null
   */
  id?: GqlID | undefined;
  /**
   * The actual time the timestamp is at
   */
  at: GqlFloat;
  /**
   * The id specifying the type the timestamp is
   */
  typeId: GqlID;
  type: GqlTimestampType;
}

export interface GqlTimestamp {
  id: GqlID;
  createdAt: GqlTime;
  createdByUserId: GqlID;
  createdBy: GqlUser;
  updatedAt: GqlTime;
  updatedByUserId: GqlID;
  updatedBy: GqlUser;
  deletedAt?: GqlTime | undefined;
  deletedByUserId?: GqlID | undefined;
  deletedBy?: GqlUser | undefined;
  /**
   * The actual time the timestamp is at
   */
  at: GqlFloat;
  source: GqlTimestampSource;
  /**
   * The id specifying the type the timestamp is
   */
  typeId: GqlID;
  /**
   * The type the timestamp is. Thid field is a constant string so including it has no effect on
   * performance or query complexity.
   */
  type: GqlTimestampType;
  /**
   * The `Episode.id` that the timestamp belongs to
   */
  episodeId: GqlID;
  /**
   * The `Episode` that the timestamp belongs to
   */
  episode: GqlEpisode;
}

/**
 * The type a timestamp can be. This table rarely changes so the values fetched can either be hard
 * coded or fetch occasionaly. Anime Skip website and web extension use hardcoded maps to store this
 * data, but a third party might want to fetch and cache this instead since you won't know when Anime
 * Skip adds timestamps
 */
export interface GqlTimestampType {
  id: GqlID;
  createdAt: GqlTime;
  createdByUserId: GqlID;
  createdBy: GqlUser;
  updatedAt: GqlTime;
  updatedByUserId: GqlID;
  updatedBy: GqlUser;
  deletedAt?: GqlTime | undefined;
  deletedByUserId?: GqlID | undefined;
  deletedBy?: GqlUser | undefined;
  /**
   * The name of the timestamp type
   */
  name: GqlString;
  /**
   * The description for what this type represents
   */
  description: GqlString;
}

export interface GqlUpdatedTimestamps {
  created: Array<GqlTimestamp>;
  updated: Array<GqlTimestamp>;
  deleted: Array<GqlTimestamp>;
}

/**
 * Information about a user that is public. See `Account` for a description of each field
 */
export interface GqlUser {
  id: GqlID;
  createdAt: GqlTime;
  deletedAt?: GqlTime | undefined;
  username: GqlString;
  profileUrl: GqlString;
  adminOfShows: Array<GqlShowAdmin>;
}

export type StatelessClient = ReturnType<typeof createStatelessClient>;

export function createStatelessClient({
  baseUrl,
  clientId,
  fetch = DEFAULT_FETCH,
}: StatelessConfig) {
  if (fetch == null) throw Error(`fetch was ${fetch}. Did you forget to provide config.fetch?`);

  /**
   * Get the logged in user's private account information
   */
  async function account(query: string, config?: RequestInit): Promise<GqlAccount> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query Account {
  account ${query}
}`,
        operationName: 'Account',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'account', GqlAccount>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['account'];
  }
  /**
   * Use either the username or email and an md5 hash of the user's password to get an access and
   * refresh token
   */
  async function login(
    query: string,
    variables?: { usernameEmail: GqlString; passwordHash: GqlString },
    config?: RequestInit,
  ): Promise<GqlLoginData> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query Login(
  $usernameEmail: String!,
  $passwordHash: String!,
) {
  login(
    usernameEmail: $usernameEmail,
    passwordHash: $passwordHash,
  ) ${query}
}`,
        variables,
        operationName: 'Login',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'login', GqlLoginData>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['login'];
  }
  /**
   * Use a refresh token get a new access and refresh token
   */
  async function loginRefresh(
    query: string,
    variables?: { refreshToken: GqlString },
    config?: RequestInit,
  ): Promise<GqlLoginData> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query LoginRefresh(
  $refreshToken: String!,
) {
  loginRefresh(
    refreshToken: $refreshToken,
  ) ${query}
}`,
        variables,
        operationName: 'LoginRefresh',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'loginRefresh', GqlLoginData>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['loginRefresh'];
  }
  /**
   * Find user with a matching `User.id`
   */
  async function findUser(
    query: string,
    variables?: { userId: GqlID },
    config?: RequestInit,
  ): Promise<GqlUser> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindUser(
  $userId: ID!,
) {
  findUser(
    userId: $userId,
  ) ${query}
}`,
        variables,
        operationName: 'FindUser',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'findUser', GqlUser>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findUser'];
  }
  /**
   * Find user with a matching `User.username`
   */
  async function findUserByUsername(
    query: string,
    variables?: { username: GqlString },
    config?: RequestInit,
  ): Promise<GqlUser> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindUserByUsername(
  $username: String!,
) {
  findUserByUsername(
    username: $username,
  ) ${query}
}`,
        variables,
        operationName: 'FindUserByUsername',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'findUserByUsername', GqlUser>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findUserByUsername'];
  }
  /**
   * Find show with a matching `Show.id`
   */
  async function findShow(
    query: string,
    variables?: { showId: GqlID },
    config?: RequestInit,
  ): Promise<GqlShow> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindShow(
  $showId: ID!,
) {
  findShow(
    showId: $showId,
  ) ${query}
}`,
        variables,
        operationName: 'FindShow',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'findShow', GqlShow>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findShow'];
  }
  /**
   * Search for shows that include the `search` in the `Show.name`. Results are sorted by `Show.name`
   * as `ASC` or `DESC`
   */
  async function searchShows(
    query: string,
    variables?: {
      search?: GqlString | undefined;
      offset?: GqlInt | undefined;
      limit?: GqlInt | undefined;
      sort?: GqlString | undefined;
    },
    config?: RequestInit,
  ): Promise<Array<GqlShow>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query SearchShows(
  $search: String,
  $offset: Int,
  $limit: Int,
  $sort: String,
) {
  searchShows(
    search: $search,
    offset: $offset,
    limit: $limit,
    sort: $sort,
  ) ${query}
}`,
        variables,
        operationName: 'SearchShows',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'searchShows', Array<GqlShow>>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['searchShows'];
  }
  /**
   * Find show admin with a matching `ShowAdmin.id`
   */
  async function findShowAdmin(
    query: string,
    variables?: { showAdminId: GqlID },
    config?: RequestInit,
  ): Promise<GqlShowAdmin> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindShowAdmin(
  $showAdminId: ID!,
) {
  findShowAdmin(
    showAdminId: $showAdminId,
  ) ${query}
}`,
        variables,
        operationName: 'FindShowAdmin',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'findShowAdmin', GqlShowAdmin>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findShowAdmin'];
  }
  /**
   * Get a list of admins for a given `Show.id`
   */
  async function findShowAdminsByShowId(
    query: string,
    variables?: { showId: GqlID },
    config?: RequestInit,
  ): Promise<Array<GqlShowAdmin>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindShowAdminsByShowId(
  $showId: ID!,
) {
  findShowAdminsByShowId(
    showId: $showId,
  ) ${query}
}`,
        variables,
        operationName: 'FindShowAdminsByShowId',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findShowAdminsByShowId',
      Array<GqlShowAdmin>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findShowAdminsByShowId'];
  }
  /**
   * Get a list of show admins for a given `User.id`
   */
  async function findShowAdminsByUserId(
    query: string,
    variables?: { userId: GqlID },
    config?: RequestInit,
  ): Promise<Array<GqlShowAdmin>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindShowAdminsByUserId(
  $userId: ID!,
) {
  findShowAdminsByUserId(
    userId: $userId,
  ) ${query}
}`,
        variables,
        operationName: 'FindShowAdminsByUserId',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findShowAdminsByUserId',
      Array<GqlShowAdmin>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findShowAdminsByUserId'];
  }
  /**
   * Get a list of recently added episodes that have timestamps.
   *
   * > Since this is a rather intensive query, it is cached for 20 minutes before it will look for new
   * > episodes again
   */
  async function recentlyAddedEpisodes(
    query: string,
    variables?: { limit?: GqlInt | undefined; offset?: GqlInt | undefined },
    config?: RequestInit,
  ): Promise<Array<GqlEpisode>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query RecentlyAddedEpisodes(
  $limit: Int,
  $offset: Int,
) {
  recentlyAddedEpisodes(
    limit: $limit,
    offset: $offset,
  ) ${query}
}`,
        variables,
        operationName: 'RecentlyAddedEpisodes',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'recentlyAddedEpisodes',
      Array<GqlEpisode>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['recentlyAddedEpisodes'];
  }
  /**
   * Find episode with a matching `Episode.id`
   */
  async function findEpisode(
    query: string,
    variables?: { episodeId: GqlID },
    config?: RequestInit,
  ): Promise<GqlEpisode> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindEpisode(
  $episodeId: ID!,
) {
  findEpisode(
    episodeId: $episodeId,
  ) ${query}
}`,
        variables,
        operationName: 'FindEpisode',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'findEpisode', GqlEpisode>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findEpisode'];
  }
  /**
   * Get a list of episodes for a given `Show.id`
   */
  async function findEpisodesByShowId(
    query: string,
    variables?: { showId: GqlID },
    config?: RequestInit,
  ): Promise<Array<GqlEpisode>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindEpisodesByShowId(
  $showId: ID!,
) {
  findEpisodesByShowId(
    showId: $showId,
  ) ${query}
}`,
        variables,
        operationName: 'FindEpisodesByShowId',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findEpisodesByShowId',
      Array<GqlEpisode>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findEpisodesByShowId'];
  }
  /**
   * Search for episodes that include the `search` in the `Episode.name`. Results are sorted by
   * `Show.name`as `ASC` or `DESC`
   *
   * Results can be limited to a single show by passing `showId`
   */
  async function searchEpisodes(
    query: string,
    variables?: {
      search?: GqlString | undefined;
      showId?: GqlID | undefined;
      offset?: GqlInt | undefined;
      limit?: GqlInt | undefined;
      sort?: GqlString | undefined;
    },
    config?: RequestInit,
  ): Promise<Array<GqlEpisode>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query SearchEpisodes(
  $search: String,
  $showId: ID,
  $offset: Int,
  $limit: Int,
  $sort: String,
) {
  searchEpisodes(
    search: $search,
    showId: $showId,
    offset: $offset,
    limit: $limit,
    sort: $sort,
  ) ${query}
}`,
        variables,
        operationName: 'SearchEpisodes',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'searchEpisodes', Array<GqlEpisode>>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['searchEpisodes'];
  }
  /**
   * Get a list of third party episodes for a given `Episode.name`. Since this can return an array of
   * multiple items, always use `findEpisodeUrl` first, then fallback to this query.
   *
   * Current 3rd party timestamp providers include:
   * - [BetterVRV](http://tuckerchap.in/BetterVRV/)
   *
   * > See `ThirdPartyEpisode` for more information about how to create data based on this type
   */
  async function findEpisodeByName(
    query: string,
    variables?: { name: GqlString },
    config?: RequestInit,
  ): Promise<Array<GqlThirdPartyEpisode>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindEpisodeByName(
  $name: String!,
) {
  findEpisodeByName(
    name: $name,
  ) ${query}
}`,
        variables,
        operationName: 'FindEpisodeByName',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findEpisodeByName',
      Array<GqlThirdPartyEpisode>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findEpisodeByName'];
  }
  /**
   * Find an episode based on a URL. This is the primary method used to lookup data for a known service
   * URL. See `findEpisodeByName` for looking up fallback data.
   */
  async function findEpisodeUrl(
    query: string,
    variables?: { episodeUrl: GqlString },
    config?: RequestInit,
  ): Promise<GqlEpisodeUrl> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindEpisodeUrl(
  $episodeUrl: String!,
) {
  findEpisodeUrl(
    episodeUrl: $episodeUrl,
  ) ${query}
}`,
        variables,
        operationName: 'FindEpisodeUrl',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'findEpisodeUrl', GqlEpisodeUrl>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findEpisodeUrl'];
  }
  /**
   * List all the `EpisodeUrl`s for a given `Episode.id`
   */
  async function findEpisodeUrlsByEpisodeId(
    query: string,
    variables?: { episodeId: GqlID },
    config?: RequestInit,
  ): Promise<Array<GqlEpisodeUrl>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindEpisodeUrlsByEpisodeId(
  $episodeId: ID!,
) {
  findEpisodeUrlsByEpisodeId(
    episodeId: $episodeId,
  ) ${query}
}`,
        variables,
        operationName: 'FindEpisodeUrlsByEpisodeId',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findEpisodeUrlsByEpisodeId',
      Array<GqlEpisodeUrl>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findEpisodeUrlsByEpisodeId'];
  }
  /**
   * Get timestamp info based on a `Timestamp.id`
   */
  async function findTimestamp(
    query: string,
    variables?: { timestampId: GqlID },
    config?: RequestInit,
  ): Promise<GqlTimestamp> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindTimestamp(
  $timestampId: ID!,
) {
  findTimestamp(
    timestampId: $timestampId,
  ) ${query}
}`,
        variables,
        operationName: 'FindTimestamp',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'findTimestamp', GqlTimestamp>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findTimestamp'];
  }
  /**
   * Get all the timestamps for an episode
   */
  async function findTimestampsByEpisodeId(
    query: string,
    variables?: { episodeId: GqlID },
    config?: RequestInit,
  ): Promise<Array<GqlTimestamp>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindTimestampsByEpisodeId(
  $episodeId: ID!,
) {
  findTimestampsByEpisodeId(
    episodeId: $episodeId,
  ) ${query}
}`,
        variables,
        operationName: 'FindTimestampsByEpisodeId',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findTimestampsByEpisodeId',
      Array<GqlTimestamp>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findTimestampsByEpisodeId'];
  }
  /**
   * Get timestamp type info based on a `TimestampType.id`
   */
  async function findTimestampType(
    query: string,
    variables?: { timestampTypeId: GqlID },
    config?: RequestInit,
  ): Promise<GqlTimestampType> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindTimestampType(
  $timestampTypeId: ID!,
) {
  findTimestampType(
    timestampTypeId: $timestampTypeId,
  ) ${query}
}`,
        variables,
        operationName: 'FindTimestampType',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findTimestampType',
      GqlTimestampType
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findTimestampType'];
  }
  /**
   * List all the `TimestampType`s. Items come back in a random order
   */
  async function allTimestampTypes(
    query: string,
    config?: RequestInit,
  ): Promise<Array<GqlTimestampType>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query AllTimestampTypes {
  allTimestampTypes ${query}
}`,
        operationName: 'AllTimestampTypes',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'allTimestampTypes',
      Array<GqlTimestampType>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['allTimestampTypes'];
  }
  /**
   * Get template info based on a `Template.id`
   */
  async function findTemplate(
    query: string,
    variables?: { templateId: GqlID },
    config?: RequestInit,
  ): Promise<GqlTemplate> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindTemplate(
  $templateId: ID!,
) {
  findTemplate(
    templateId: $templateId,
  ) ${query}
}`,
        variables,
        operationName: 'FindTemplate',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'findTemplate', GqlTemplate>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findTemplate'];
  }
  /**
   * Get a list of templates based on the `Template.showId`
   */
  async function findTemplatesByShowId(
    query: string,
    variables?: { showId: GqlID },
    config?: RequestInit,
  ): Promise<Array<GqlTemplate>> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindTemplatesByShowId(
  $showId: ID!,
) {
  findTemplatesByShowId(
    showId: $showId,
  ) ${query}
}`,
        variables,
        operationName: 'FindTemplatesByShowId',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findTemplatesByShowId',
      Array<GqlTemplate>
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findTemplatesByShowId'];
  }
  /**
   * Find the most relevant template based on a few search criteria. If multiple templates are found,
   * their priority is like so:
   *
   * 1. Matching `sourceEpisodeID`
   * 2. Matching show name (case sensitive) and season (case sensitive)
   * 3. Matching show name (case sensitive)
   */
  async function findTemplateByDetails(
    query: string,
    variables?: {
      episodeId?: GqlID | undefined;
      showName?: GqlString | undefined;
      season?: GqlString | undefined;
    },
    config?: RequestInit,
  ): Promise<GqlTemplate> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `query FindTemplateByDetails(
  $episodeId: ID,
  $showName: String,
  $season: String,
) {
  findTemplateByDetails(
    episodeId: $episodeId,
    showName: $showName,
    season: $season,
  ) ${query}
}`,
        variables,
        operationName: 'FindTemplateByDetails',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'findTemplateByDetails',
      GqlTemplate
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['findTemplateByDetails'];
  }
  /**
   * Create a user account. 3rd party applications will not have access to this function because of
   * `recaptchaResponse`. Redirect new users to create an account on <anime-skip.com>
   */
  async function createAccount(
    query: string,
    variables?: {
      username: GqlString;
      email: GqlString;
      passwordHash: GqlString;
      recaptchaResponse: GqlString;
    },
    config?: RequestInit,
  ): Promise<GqlLoginData> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation CreateAccount(
  $username: String!,
  $email: String!,
  $passwordHash: String!,
  $recaptchaResponse: String!,
) {
  createAccount(
    username: $username,
    email: $email,
    passwordHash: $passwordHash,
    recaptchaResponse: $recaptchaResponse,
  ) ${query}
}`,
        variables,
        operationName: 'CreateAccount',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'createAccount', GqlLoginData>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['createAccount'];
  }
  /**
   * Change a user's password by first confirming the old one. This is not a forgot password flow
   *
   * > Note the passwords aren't md5 hashes. The regular login will be moving to this as well eventually
   */
  async function changePassword(
    query: string,
    variables?: { oldPassword: GqlString; newPassword: GqlString; confirmNewPassword: GqlString },
    config?: RequestInit,
  ): Promise<GqlLoginData> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation ChangePassword(
  $oldPassword: String!,
  $newPassword: String!,
  $confirmNewPassword: String!,
) {
  changePassword(
    oldPassword: $oldPassword,
    newPassword: $newPassword,
    confirmNewPassword: $confirmNewPassword,
  ) ${query}
}`,
        variables,
        operationName: 'ChangePassword',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'changePassword', GqlLoginData>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['changePassword'];
  }
  /**
   * Resend the verification email for the account of the authenticated user
   */
  async function resendVerificationEmail(
    query: string,
    variables?: { recaptchaResponse: GqlString },
    config?: RequestInit,
  ): Promise<GqlBoolean | undefined> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation ResendVerificationEmail(
  $recaptchaResponse: String!,
) {
  resendVerificationEmail(
    recaptchaResponse: $recaptchaResponse,
  ) ${query}
}`,
        variables,
        operationName: 'ResendVerificationEmail',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'resendVerificationEmail',
      GqlBoolean | undefined
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['resendVerificationEmail'];
  }
  /**
   * Callback to handle the verification token included in the email sent using
   * `resendVerificationEmail`
   */
  async function verifyEmailAddress(
    query: string,
    variables?: { validationToken: GqlString },
    config?: RequestInit,
  ): Promise<GqlAccount> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation VerifyEmailAddress(
  $validationToken: String!,
) {
  verifyEmailAddress(
    validationToken: $validationToken,
  ) ${query}
}`,
        variables,
        operationName: 'VerifyEmailAddress',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'verifyEmailAddress', GqlAccount>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['verifyEmailAddress'];
  }
  /**
   * The first step in the password reset process
   *
   * It sends an email containing a link to reset your password with. That link includes a token, the
   * `passwordResetToken`, that can be passed into the `resetPassword` mutation.
   *
   * > Because the `recaptchaResponse` is required, this can not be performed by 3rd parties
   */
  async function requestPasswordReset(
    query: string,
    variables?: { recaptchaResponse: GqlString; email: GqlString },
    config?: RequestInit,
  ): Promise<GqlBoolean> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation RequestPasswordReset(
  $recaptchaResponse: String!,
  $email: String!,
) {
  requestPasswordReset(
    recaptchaResponse: $recaptchaResponse,
    email: $email,
  ) ${query}
}`,
        variables,
        operationName: 'RequestPasswordReset',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'requestPasswordReset', GqlBoolean>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['requestPasswordReset'];
  }
  /**
   * The second step in the password reset process, coming after `requestPasswordReset`
   *
   * This step is pretty self explanatory, this is when the password is actually reset for a user
   */
  async function resetPassword(
    query: string,
    variables?: {
      passwordResetToken: GqlString;
      newPassword: GqlString;
      confirmNewPassword: GqlString;
    },
    config?: RequestInit,
  ): Promise<GqlLoginData> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation ResetPassword(
  $passwordResetToken: String!,
  $newPassword: String!,
  $confirmNewPassword: String!,
) {
  resetPassword(
    passwordResetToken: $passwordResetToken,
    newPassword: $newPassword,
    confirmNewPassword: $confirmNewPassword,
  ) ${query}
}`,
        variables,
        operationName: 'ResetPassword',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'resetPassword', GqlLoginData>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['resetPassword'];
  }
  /**
   * Request your account be deleted. The user will receive an email with a link to confirm deleting
   * their account
   */
  async function deleteAccountRequest(
    query: string,
    variables?: { passwordHash: GqlString },
    config?: RequestInit,
  ): Promise<GqlAccount> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteAccountRequest(
  $passwordHash: String!,
) {
  deleteAccountRequest(
    passwordHash: $passwordHash,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteAccountRequest',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'deleteAccountRequest', GqlAccount>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteAccountRequest'];
  }
  /**
   * Handle a deleteToken from `deleteAccountRequest` and actually delete the user's account
   */
  async function deleteAccount(
    query: string,
    variables?: { deleteToken: GqlString },
    config?: RequestInit,
  ): Promise<GqlAccount> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteAccount(
  $deleteToken: String!,
) {
  deleteAccount(
    deleteToken: $deleteToken,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteAccount',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'deleteAccount', GqlAccount>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteAccount'];
  }
  /**
   * Update user preferences
   */
  async function savePreferences(
    query: string,
    variables?: { preferences: GqlInputPreferences },
    config?: RequestInit,
  ): Promise<GqlPreferences> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation SavePreferences(
  $preferences: InputPreferences!,
) {
  savePreferences(
    preferences: $preferences,
  ) ${query}
}`,
        variables,
        operationName: 'SavePreferences',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'savePreferences', GqlPreferences>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['savePreferences'];
  }
  /**
   * Create a show and optionally become an admin
   */
  async function createShow(
    query: string,
    variables?: { showInput: GqlInputShow; becomeAdmin: GqlBoolean },
    config?: RequestInit,
  ): Promise<GqlShow> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation CreateShow(
  $showInput: InputShow!,
  $becomeAdmin: Boolean!,
) {
  createShow(
    showInput: $showInput,
    becomeAdmin: $becomeAdmin,
  ) ${query}
}`,
        variables,
        operationName: 'CreateShow',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'createShow', GqlShow>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['createShow'];
  }
  /**
   * Update show data
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function updateShow(
    query: string,
    variables?: { showId: GqlID; newShow: GqlInputShow },
    config?: RequestInit,
  ): Promise<GqlShow> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation UpdateShow(
  $showId: ID!,
  $newShow: InputShow!,
) {
  updateShow(
    showId: $showId,
    newShow: $newShow,
  ) ${query}
}`,
        variables,
        operationName: 'UpdateShow',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'updateShow', GqlShow>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['updateShow'];
  }
  /**
   * Delete a show and all it's children (episodes, episode urls, timestamps, admins, etc)
   *
   * > `@hasRole(role: ADMIN)` - The user must have the `ADMIN` role to perform this action
   */
  async function deleteShow(
    query: string,
    variables?: { showId: GqlID },
    config?: RequestInit,
  ): Promise<GqlShow> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteShow(
  $showId: ID!,
) {
  deleteShow(
    showId: $showId,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteShow',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'deleteShow', GqlShow>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteShow'];
  }
  /**
   * Give admin privilege to a user for a show.
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function createShowAdmin(
    query: string,
    variables?: { showAdminInput: GqlInputShowAdmin },
    config?: RequestInit,
  ): Promise<GqlShowAdmin> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation CreateShowAdmin(
  $showAdminInput: InputShowAdmin!,
) {
  createShowAdmin(
    showAdminInput: $showAdminInput,
  ) ${query}
}`,
        variables,
        operationName: 'CreateShowAdmin',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'createShowAdmin', GqlShowAdmin>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['createShowAdmin'];
  }
  /**
   * Remove admin privileges from a user for a show.
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function deleteShowAdmin(
    query: string,
    variables?: { showAdminId: GqlID },
    config?: RequestInit,
  ): Promise<GqlShowAdmin> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteShowAdmin(
  $showAdminId: ID!,
) {
  deleteShowAdmin(
    showAdminId: $showAdminId,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteShowAdmin',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'deleteShowAdmin', GqlShowAdmin>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteShowAdmin'];
  }
  /**
   * Create an episode under a `Show`
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function createEpisode(
    query: string,
    variables?: { showId: GqlID; episodeInput: GqlInputEpisode },
    config?: RequestInit,
  ): Promise<GqlEpisode> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation CreateEpisode(
  $showId: ID!,
  $episodeInput: InputEpisode!,
) {
  createEpisode(
    showId: $showId,
    episodeInput: $episodeInput,
  ) ${query}
}`,
        variables,
        operationName: 'CreateEpisode',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'createEpisode', GqlEpisode>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['createEpisode'];
  }
  /**
   * Update episode info
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function updateEpisode(
    query: string,
    variables?: { episodeId: GqlID; newEpisode: GqlInputEpisode },
    config?: RequestInit,
  ): Promise<GqlEpisode> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation UpdateEpisode(
  $episodeId: ID!,
  $newEpisode: InputEpisode!,
) {
  updateEpisode(
    episodeId: $episodeId,
    newEpisode: $newEpisode,
  ) ${query}
}`,
        variables,
        operationName: 'UpdateEpisode',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'updateEpisode', GqlEpisode>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['updateEpisode'];
  }
  /**
   * Delete an episode and all it's child data
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function deleteEpisode(
    query: string,
    variables?: { episodeId: GqlID },
    config?: RequestInit,
  ): Promise<GqlEpisode> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteEpisode(
  $episodeId: ID!,
) {
  deleteEpisode(
    episodeId: $episodeId,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteEpisode',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'deleteEpisode', GqlEpisode>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteEpisode'];
  }
  /**
   * Link an `Episode` to a service URL
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function createEpisodeUrl(
    query: string,
    variables?: { episodeId: GqlID; episodeUrlInput: GqlInputEpisodeUrl },
    config?: RequestInit,
  ): Promise<GqlEpisodeUrl> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation CreateEpisodeUrl(
  $episodeId: ID!,
  $episodeUrlInput: InputEpisodeUrl!,
) {
  createEpisodeUrl(
    episodeId: $episodeId,
    episodeUrlInput: $episodeUrlInput,
  ) ${query}
}`,
        variables,
        operationName: 'CreateEpisodeUrl',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'createEpisodeUrl', GqlEpisodeUrl>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['createEpisodeUrl'];
  }
  /**
   * Unlink an `Episode` to from service URL
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function deleteEpisodeUrl(
    query: string,
    variables?: { episodeUrl: GqlString },
    config?: RequestInit,
  ): Promise<GqlEpisodeUrl> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteEpisodeUrl(
  $episodeUrl: String!,
) {
  deleteEpisodeUrl(
    episodeUrl: $episodeUrl,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteEpisodeUrl',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'deleteEpisodeUrl', GqlEpisodeUrl>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteEpisodeUrl'];
  }
  /**
   * Update episode url info
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function updateEpisodeUrl(
    query: string,
    variables?: { episodeUrl: GqlString; newEpisodeUrl: GqlInputEpisodeUrl },
    config?: RequestInit,
  ): Promise<GqlEpisodeUrl> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation UpdateEpisodeUrl(
  $episodeUrl: String!,
  $newEpisodeUrl: InputEpisodeUrl!,
) {
  updateEpisodeUrl(
    episodeUrl: $episodeUrl,
    newEpisodeUrl: $newEpisodeUrl,
  ) ${query}
}`,
        variables,
        operationName: 'UpdateEpisodeUrl',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'updateEpisodeUrl', GqlEpisodeUrl>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['updateEpisodeUrl'];
  }
  /**
   * Add a timestamp to an `Episode`
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function createTimestamp(
    query: string,
    variables?: { episodeId: GqlID; timestampInput: GqlInputTimestamp },
    config?: RequestInit,
  ): Promise<GqlTimestamp> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation CreateTimestamp(
  $episodeId: ID!,
  $timestampInput: InputTimestamp!,
) {
  createTimestamp(
    episodeId: $episodeId,
    timestampInput: $timestampInput,
  ) ${query}
}`,
        variables,
        operationName: 'CreateTimestamp',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'createTimestamp', GqlTimestamp>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['createTimestamp'];
  }
  /**
   * Update timestamp data
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function updateTimestamp(
    query: string,
    variables?: { timestampId: GqlID; newTimestamp: GqlInputTimestamp },
    config?: RequestInit,
  ): Promise<GqlTimestamp> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation UpdateTimestamp(
  $timestampId: ID!,
  $newTimestamp: InputTimestamp!,
) {
  updateTimestamp(
    timestampId: $timestampId,
    newTimestamp: $newTimestamp,
  ) ${query}
}`,
        variables,
        operationName: 'UpdateTimestamp',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'updateTimestamp', GqlTimestamp>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['updateTimestamp'];
  }
  /**
   * Delete a timestamp
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function deleteTimestamp(
    query: string,
    variables?: { timestampId: GqlID },
    config?: RequestInit,
  ): Promise<GqlTimestamp> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteTimestamp(
  $timestampId: ID!,
) {
  deleteTimestamp(
    timestampId: $timestampId,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteTimestamp',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'deleteTimestamp', GqlTimestamp>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteTimestamp'];
  }
  /**
   * Will create, update, and delete timestamps as passed. Partial failures are completely rolled back
   *
   * > `@isShowAdmin` - You need to be an admin of the show to do this action
   */
  async function updateTimestamps(
    query: string,
    variables?: {
      create: Array<GqlInputTimestampOn>;
      update: Array<GqlInputExistingTimestamp>;
      delete_: Array<GqlID>;
    },
    config?: RequestInit,
  ): Promise<GqlUpdatedTimestamps> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation UpdateTimestamps(
  $create: [InputTimestampOn!]!,
  $update: [InputExistingTimestamp!]!,
  $delete: [ID!]!,
) {
  updateTimestamps(
    create: $create,
    update: $update,
    delete: $delete,
  ) ${query}
}`,
        variables,
        operationName: 'UpdateTimestamps',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'updateTimestamps',
      GqlUpdatedTimestamps
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['updateTimestamps'];
  }
  /**
   * Create a timestamp type
   *
   * > `@hasRole(role: ADMIN)` - The user must have the `ADMIN` role to perform this action
   */
  async function createTimestampType(
    query: string,
    variables?: { timestampTypeInput: GqlInputTimestampType },
    config?: RequestInit,
  ): Promise<GqlTimestampType> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation CreateTimestampType(
  $timestampTypeInput: InputTimestampType!,
) {
  createTimestampType(
    timestampTypeInput: $timestampTypeInput,
  ) ${query}
}`,
        variables,
        operationName: 'CreateTimestampType',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'createTimestampType',
      GqlTimestampType
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['createTimestampType'];
  }
  /**
   * Update a timestamp type
   *
   * > `@hasRole(role: ADMIN)` - The user must have the `ADMIN` role to perform this action
   */
  async function updateTimestampType(
    query: string,
    variables?: { timestampTypeId: GqlID; newTimestampType: GqlInputTimestampType },
    config?: RequestInit,
  ): Promise<GqlTimestampType> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation UpdateTimestampType(
  $timestampTypeId: ID!,
  $newTimestampType: InputTimestampType!,
) {
  updateTimestampType(
    timestampTypeId: $timestampTypeId,
    newTimestampType: $newTimestampType,
  ) ${query}
}`,
        variables,
        operationName: 'UpdateTimestampType',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'updateTimestampType',
      GqlTimestampType
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['updateTimestampType'];
  }
  /**
   * Delete a timestamp type
   *
   * > `@hasRole(role: ADMIN)` - The user must have the `ADMIN` role to perform this action
   */
  async function deleteTimestampType(
    query: string,
    variables?: { timestampTypeId: GqlID },
    config?: RequestInit,
  ): Promise<GqlTimestampType> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteTimestampType(
  $timestampTypeId: ID!,
) {
  deleteTimestampType(
    timestampTypeId: $timestampTypeId,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteTimestampType',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'deleteTimestampType',
      GqlTimestampType
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteTimestampType'];
  }
  /**
   * Make changes to an existing template
   */
  async function createTemplate(
    query: string,
    variables?: { newTemplate: GqlInputTemplate },
    config?: RequestInit,
  ): Promise<GqlTemplate> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation CreateTemplate(
  $newTemplate: InputTemplate!,
) {
  createTemplate(
    newTemplate: $newTemplate,
  ) ${query}
}`,
        variables,
        operationName: 'CreateTemplate',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'createTemplate', GqlTemplate>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['createTemplate'];
  }
  /**
   * Make changes to an existing template
   */
  async function updateTemplate(
    query: string,
    variables?: { templateId: GqlID; newTemplate: GqlInputTemplate },
    config?: RequestInit,
  ): Promise<GqlTemplate> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation UpdateTemplate(
  $templateId: ID!,
  $newTemplate: InputTemplate!,
) {
  updateTemplate(
    templateId: $templateId,
    newTemplate: $newTemplate,
  ) ${query}
}`,
        variables,
        operationName: 'UpdateTemplate',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'updateTemplate', GqlTemplate>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['updateTemplate'];
  }
  /**
   * Delete an existing template
   */
  async function deleteTemplate(
    query: string,
    variables?: { templateId: GqlID },
    config?: RequestInit,
  ): Promise<GqlTemplate> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation DeleteTemplate(
  $templateId: ID!,
) {
  deleteTemplate(
    templateId: $templateId,
  ) ${query}
}`,
        variables,
        operationName: 'DeleteTemplate',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<'deleteTemplate', GqlTemplate>;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['deleteTemplate'];
  }
  /**
   * Add a timestamp to an existing template
   */
  async function addTimestampToTemplate(
    query: string,
    variables?: { templateTimestamp: GqlInputTemplateTimestamp },
    config?: RequestInit,
  ): Promise<GqlTemplateTimestamp> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation AddTimestampToTemplate(
  $templateTimestamp: InputTemplateTimestamp!,
) {
  addTimestampToTemplate(
    templateTimestamp: $templateTimestamp,
  ) ${query}
}`,
        variables,
        operationName: 'AddTimestampToTemplate',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'addTimestampToTemplate',
      GqlTemplateTimestamp
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['addTimestampToTemplate'];
  }
  /**
   * Remove a timestamp from an existing template
   */
  async function removeTimestampFromTemplate(
    query: string,
    variables?: { templateTimestamp: GqlInputTemplateTimestamp },
    config?: RequestInit,
  ): Promise<GqlTemplateTimestamp> {
    const res = await fetch(baseUrl + '/graphql', {
      ...config,
      method: 'POST',
      body: JSON.stringify({
        query: `mutation RemoveTimestampFromTemplate(
  $templateTimestamp: InputTemplateTimestamp!,
) {
  removeTimestampFromTemplate(
    templateTimestamp: $templateTimestamp,
  ) ${query}
}`,
        variables,
        operationName: 'RemoveTimestampFromTemplate',
      }),
      headers: {
        ...config?.headers,
        'X-Client-ID': clientId,
        'Content-Type': 'application/json',
      },
    });
    const { data, errors } = (await res.json()) as GqlResponse<
      'removeTimestampFromTemplate',
      GqlTemplateTimestamp
    >;
    if (errors != null) throw new GqlError(res.status, errors);
    return data['removeTimestampFromTemplate'];
  }

  async function healthCheck(): Promise<ApiHealth> {
    const res = await fetch(baseUrl + '/status', { headers: { 'X-Client-ID': clientId } });
    const payload = await res.json();
    const { errors } = payload;
    if (errors != null) throw new GqlError(res.status, errors);
    return payload;
  }
  return {
    account,
    login,
    loginRefresh,
    findUser,
    findUserByUsername,
    findShow,
    searchShows,
    findShowAdmin,
    findShowAdminsByShowId,
    findShowAdminsByUserId,
    recentlyAddedEpisodes,
    findEpisode,
    findEpisodesByShowId,
    searchEpisodes,
    findEpisodeByName,
    findEpisodeUrl,
    findEpisodeUrlsByEpisodeId,
    findTimestamp,
    findTimestampsByEpisodeId,
    findTimestampType,
    allTimestampTypes,
    findTemplate,
    findTemplatesByShowId,
    findTemplateByDetails,
    createAccount,
    changePassword,
    resendVerificationEmail,
    verifyEmailAddress,
    requestPasswordReset,
    resetPassword,
    deleteAccountRequest,
    deleteAccount,
    savePreferences,
    createShow,
    updateShow,
    deleteShow,
    createShowAdmin,
    deleteShowAdmin,
    createEpisode,
    updateEpisode,
    deleteEpisode,
    createEpisodeUrl,
    deleteEpisodeUrl,
    updateEpisodeUrl,
    createTimestamp,
    updateTimestamp,
    deleteTimestamp,
    updateTimestamps,
    createTimestampType,
    updateTimestampType,
    deleteTimestampType,
    createTemplate,
    updateTemplate,
    deleteTemplate,
    addTimestampToTemplate,
    removeTimestampFromTemplate,
    healthCheck,
  };
}
